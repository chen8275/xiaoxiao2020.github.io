<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis参数格式化异常]]></title>
    <url>%2F2019%2F09%2F11%2Fmybatis%20%E5%8F%82%E6%95%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[昨天运行程序，程序报了mybatis参数格式化异常:NumberFormatException: For input string:”xx”，错误日志如下： 错误日记12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879[16/08/16 02:15:40:040 CST] http-nio-8080-exec-4 ERROR filter.ExceptionFilter: [DUBBO] Got unchecked and undeclared exception which called by 127.0.0.1. service: cn.test.web.service.ShareService, method: getShareChannelStInfoList, exception: org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.NumberFormatException: For input string: "2016-08-11"### Cause: java.lang.NumberFormatException: For input string: "2016-08-11", dubbo version: 2.8.4, current host: 127.0.0.1org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.NumberFormatException: For input string: "2016-08-11"### Cause: java.lang.NumberFormatException: For input string: "2016-08-11" at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:76) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:399) at com.sun.proxy.$Proxy32.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:205) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:122) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:64) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:53) at com.sun.proxy.$Proxy57.getShareChannelStInfo(Unknown Source) at cn.test.web.repository.ShareStInfoRepo.getShareChannelList(ShareStInfoRepo.java:37) at cn.test.web.impl.ShareServiceImpl.getShareChannelStInfoList(ShareServiceImpl.java:72) at com.alibaba.dubbo.common.bytecode.Wrapper19.invokeMethod(Wrapper19.java) at com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory$1.doInvoke(JavassistProxyFactory.java:46) at com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker.invoke(AbstractProxyInvoker.java:72) at com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:53) at com.alibaba.dubbo.rpc.filter.ExceptionFilter.invoke(ExceptionFilter.java:64) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.TimeoutFilter.invoke(TimeoutFilter.java:42) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter.invoke(TraceFilter.java:78) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.ContextFilter.invoke(ContextFilter.java:70) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.GenericFilter.invoke(GenericFilter.java:132) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.ClassLoaderFilter.invoke(ClassLoaderFilter.java:38) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.EchoFilter.invoke(EchoFilter.java:38) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:52) at com.alibaba.dubbo.common.bytecode.proxy9.getShareChannelStInfoList(proxy9.java) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:137) at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:288) at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:242) at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:229) at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:356) at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:179) at org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:220) at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:56) at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:51) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer$RestHandler.handle(DubboHttpServer.java:86) at com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet.service(DispatcherServlet.java:64) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:616) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:528) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1099) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1520) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1476) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 错误代码这段代码，就是mybatis的动态查询，就是组装sql语句。但是，这里必须注意一个问题，那就是departmentName 和 ordertime,这两个变量是EarlyOrder中的私有变量，是String类型的。 错误的引起，是 departmentName != 0 引起的，原因给的是字符串，却拿一个数字比较，mybatis会做一些转化，结果在数字格式化时发生异常。 1234567891011121314&lt;select id="selectEarlyOrder" resultType="com.example.demo.model.EarlyOrder"&gt; select username,ordertime,overworktime,status,departmentname from tabordermeal &lt;where&gt; 1=1 &lt;if test="departmentName != 0 and departmentName != '' and departmentName !=null and departmentName != 'null'"&gt; and departmentName = #&#123;departmentName&#125; &lt;/if&gt; &lt;if test="ordertime != '' and ordertime !=null and ordertime != 'null'"&gt; and ordertime LIKE '$&#123;ordertime&#125;%' &lt;/if&gt; &lt;/where&gt; limit #&#123;pageindex&#125;,#&#123;pagesize&#125; &lt;/select&gt; 解决错误加单引号是无法解决的，比如：departmentName != &#39;0&#39;，此时，mybatis认为拿一个字符串(String)和一个字符(char)比较，也会报错。 因此，有几种方法可以解决此问题： 转成字符串：&#39;0&#39;.toString()1234567891011121314&lt;select id="selectEarlyOrder" resultType="com.example.demo.model.EarlyOrder"&gt; select username,ordertime,overworktime,status,departmentname from tabordermeal &lt;where&gt; 1=1 &lt;if test="departmentName != '0'.toString() and departmentName != '' and departmentName !=null and departmentName != 'null'"&gt; and departmentName = #&#123;departmentName&#125; &lt;/if&gt; &lt;if test="ordertime != '' and ordertime !=null and ordertime != 'null'"&gt; and ordertime LIKE '$&#123;ordertime&#125;%' &lt;/if&gt; &lt;/where&gt; limit #&#123;pageindex&#125;,#&#123;pagesize&#125; &lt;/select&gt; 加转义实体字符串引号&amp;quot;1&lt;if test=\"departmentName != null and departmentName != "0"\"&gt; 外部单双引号交换：1&lt;if test='startd != null and startd != \"0\"'&gt; 注意：在xml配置中，使用第三种方式，不需要添加反斜杠(“\“),&lt;if test=&#39;startd != null and startd != &quot;0&quot;&#39;&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 集成 redis 分布式锁]]></title>
    <url>%2F2019%2F07%2F06%2FSpringBoot%20%E9%9B%86%E6%88%90%20redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[继上一篇 SpringBoot 整合 redis 踩坑日志之后，又学习了 redis 分布式锁，那为什么需要分布式锁？ redis 分布式锁原理在传统单体应用单机部署的情况下，可以使用Java并发相关的锁，如ReentrantLcok或synchronized进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统，渐渐的被部署在多机器多JVM上同时提供服务，这使得原单机部署情况下的并发控制锁策略失效了，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。 分布式锁的实现条件 互斥性，和单体应用一样，要保证任意时刻，只能有一个客户端持有锁 可靠性，要保证系统的稳定性，不能产生死锁 一致性，要保证锁只能由加锁人解锁，不能产生A的加锁被B用户解锁的情况 分布式锁的实现Redis实现分布式锁不同的人可能有不同的实现逻辑，但是核心就是下面三个方法。 1.SETNXSETNX key val 当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回1；若 key存在，则什么都不做，返回0。 2.Expireexpire key timeout 为 key 设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。 3.Deletedelete key 删除 key 。 原理图如下： redis 分布式锁实战项目代码结构图 导入依赖在 pom.xml 中添加 starter-web、starter-aop、starter-data-redis 的依赖 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 属性配置在 application.properites 资源文件中添加 redis 相关的配置项 1234567891011121314151617181920server: port: 1999spring: datasource: url: jdbc:mysql://127.0.0.1:3306/mybatis-plus-test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai driverClassName: com.mysql.cj.jdbc.Driver username: root password: root redis: host: 127.0.0.1 port: 6379 timeout: 5000ms password: database: 0 jedis: pool: max-active: 50 max-wait: 3000ms max-idle: 20 min-idle: 2 注解1.创建一个 CacheLock 注解，属性配置如下 prefix： 缓存中 key 的前缀 expire： 过期时间，此处默认为 5 秒 timeUnit： 超时单位，此处默认为秒 delimiter： key 的分隔符，将不同参数值分割开来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.tuhu.twosample.chen.distributed.annotation;import java.lang.annotation.*;import java.util.concurrent.TimeUnit;/** * 锁的注解 * @author chendesheng * @create 2019/10/11 16:06 */@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface CacheLock &#123; /** * redis 锁key的前缀 * * @return redis 锁key的前缀 */ String prefix() default ""; /** * 过期秒数,默认为5秒 * * @return 轮询锁的时间 */ int expire() default 5; /** * 超时时间单位 * * @return 秒 */ TimeUnit timeUnit() default TimeUnit.SECONDS; /** * &lt;p&gt;Key的分隔符（默认 :）&lt;/p&gt; * &lt;p&gt;生成的Key：N:SO1008:500&lt;/p&gt; * * @return String */ String delimiter() default ":";&#125; 2、 key 的生成规则是自己定义的，如果通过表达式语法自己得去写解析规则还是比较麻烦的，所以依旧是用注解的方式 12345678910111213141516171819202122package com.tuhu.twosample.chen.distributed.annotation;import java.lang.annotation.*;/** * 锁的参数 * @author chendesheng * @create 2019/10/11 16:08 */@Target(&#123;ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface CacheParam &#123; /** * 字段名称 * * @return String */ String name() default "";&#125; key生成策略1、接口 12345678910111213141516171819package com.tuhu.twosample.chen.distributed.common;import org.aspectj.lang.ProceedingJoinPoint;/** * key生成器 * @author chendesheng * @create 2019/10/11 16:09 */public interface CacheKeyGenerator &#123; /** * 获取AOP参数,生成指定缓存Key * * @param pjp PJP * @return 缓存KEY */ String getLockKey(ProceedingJoinPoint pjp);&#125; 2、接口实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.tuhu.twosample.chen.distributed.common;import com.tuhu.twosample.chen.distributed.annotation.CacheLock;import com.tuhu.twosample.chen.distributed.annotation.CacheParam;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.util.ReflectionUtils;import org.springframework.util.StringUtils;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Parameter;/** * 通过接口注入的方式去写不同的生成规则 * @author chendesheng * @create 2019/10/11 16:09 */public class LockKeyGenerator implements CacheKeyGenerator &#123; @Override public String getLockKey(ProceedingJoinPoint pjp) &#123; MethodSignature signature = (MethodSignature) pjp.getSignature(); Method method = signature.getMethod(); CacheLock lockAnnotation = method.getAnnotation(CacheLock.class); final Object[] args = pjp.getArgs(); final Parameter[] parameters = method.getParameters(); StringBuilder builder = new StringBuilder(); //默认解析方法里面带 CacheParam 注解的属性,如果没有尝试着解析实体对象中的 for (int i = 0; i &lt; parameters.length; i++) &#123; final CacheParam annotation = parameters[i].getAnnotation(CacheParam.class); if (annotation == null) &#123; continue; &#125; builder.append(lockAnnotation.delimiter()).append(args[i]); &#125; if (StringUtils.isEmpty(builder.toString())) &#123; final Annotation[][] parameterAnnotations = method.getParameterAnnotations(); for (int i = 0; i &lt; parameterAnnotations.length; i++) &#123; final Object object = args[i]; final Field[] fields = object.getClass().getDeclaredFields(); for (Field field : fields) &#123; final CacheParam annotation = field.getAnnotation(CacheParam.class); if (annotation == null) &#123; continue; &#125; field.setAccessible(true); builder.append(lockAnnotation.delimiter()).append(ReflectionUtils.getField(field, object)); &#125; &#125; &#125; return lockAnnotation.prefix() + builder.toString(); &#125;&#125; Lock拦截器（AOP）熟悉 Redis 的朋友都知道它是线程安全的，我们利用它的特性可以很轻松的实现一个分布式锁，如 opsForValue().setIfAbsent(key,value)它的作用就是如果缓存中没有当前 Key 则进行缓存同时返回 true 反之亦然；当缓存后给 key 在设置个过期时间，防止因为系统崩溃而导致锁迟迟不释放形成死锁； 那么我们是不是可以这样认为当返回 true 我们认为它获取到锁了，在锁未释放的时候我们进行异常的抛出…. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.tuhu.twosample.chen.distributed.interceptor;import com.tuhu.twosample.chen.distributed.annotation.CacheLock;import com.tuhu.twosample.chen.distributed.common.CacheKeyGenerator;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.util.StringUtils;import java.lang.reflect.Method;/** * @author chendesheng * @create 2019/10/11 16:11 */@Aspect@Configurationpublic class LockMethodInterceptor &#123; @Autowired public LockMethodInterceptor(StringRedisTemplate lockRedisTemplate, CacheKeyGenerator cacheKeyGenerator) &#123; this.lockRedisTemplate = lockRedisTemplate; this.cacheKeyGenerator = cacheKeyGenerator; &#125; private final StringRedisTemplate lockRedisTemplate; private final CacheKeyGenerator cacheKeyGenerator; @Around("execution(public * *(..)) &amp;&amp; @annotation(com.tuhu.twosample.chen.distributed.annotation.CacheLock)") public Object interceptor(ProceedingJoinPoint pjp) &#123; MethodSignature signature = (MethodSignature) pjp.getSignature(); Method method = signature.getMethod(); CacheLock lock = method.getAnnotation(CacheLock.class); if (StringUtils.isEmpty(lock.prefix())) &#123; throw new RuntimeException("lock key can't be null..."); &#125; final String lockKey = cacheKeyGenerator.getLockKey(pjp); try &#123; //key不存在才能设置成功 final Boolean success = lockRedisTemplate.opsForValue().setIfAbsent(lockKey, ""); if (success) &#123; lockRedisTemplate.expire(lockKey, lock.expire(), lock.timeUnit()); &#125; else &#123; //按理来说 我们应该抛出一个自定义的 CacheLockException 异常; throw new RuntimeException("请勿重复请求"); &#125; try &#123; return pjp.proceed(); &#125; catch (Throwable throwable) &#123; throw new RuntimeException("系统异常"); &#125; &#125; finally &#123; //如果演示的话需要注释该代码;实际应该放开 // lockRedisTemplate.delete(lockKey); &#125; &#125;&#125; 控制层在接口方法上添加 @CacheLock(prefix = &quot;test&quot;)，然后动态的值可以加上@CacheParam；生成后的新 key 将被缓存起来；（如：该接口 token = 1，那么最终的 key 值为 test:1，如果多个条件则依次类推） 1234567891011121314151617181920212223package com.tuhu.twosample.chen.controller;import com.tuhu.twosample.chen.distributed.annotation.CacheLock;import com.tuhu.twosample.chen.distributed.annotation.CacheParam;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * @author chendesheng * @create 2019/10/11 16:13 */@RestController@RequestMapping("/chen/lock")@Slf4jpublic class LockController &#123; @CacheLock(prefix = "test") @GetMapping("/test") public String query(@CacheParam(name = "token") @RequestParam String token) &#123; return "success - " + token; &#125;&#125; 主函数需要注入前面定义好的 CacheKeyGenerator 接口具体实现 …. 12345678910111213141516171819202122232425package com.tuhu.twosample;import com.tuhu.twosample.chen.distributed.common.CacheKeyGenerator;import com.tuhu.twosample.chen.distributed.common.LockKeyGenerator;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;/** * @author chendesheng * @since 2019-08-06 */@SpringBootApplication@MapperScan("com.baomidou.mybatisplus.samples.quickstart.mapper")@MapperScan("com.tuhu.twosample.chen.mapper")public class TwoSampleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TwoSampleApplication.class, args); &#125; @Bean public CacheKeyGenerator cacheKeyGenerator() &#123; return new LockKeyGenerator(); &#125;&#125; 测试启动项目，在postman中输入url：&lt;http://localhost:1999/chen/lock/test?token=1 &gt; 第一次请求结果： 第二次请求结果： 等key过期了请求又恢复正常。 最后但是这种分布式锁也存在着缺陷，如果A在setnx成功后，A成功获取锁了，也就是锁已经存到 Redis 里面了，此时服务器异常关闭或是重启，将不会执行我们的业务逻辑，也就不会设置锁的有效期，这样的话锁就不会释放了，就会产生死锁。 所以还需要对锁进行优化，好好学习学习，嘎嘎嘎嘎。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合 redis 踩坑日志]]></title>
    <url>%2F2019%2F07%2F01%2FSpringBoot%20%E6%95%B4%E5%90%88%20redis%20%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[SpringBoot 中除了了对常用的关系型数据库提供了优秀的自动化测试以外，对于很多 NoSQL 数据库一样提供了自动化配置的支持，包括：Redis, MongoDB, Elasticsearch, Solr 和 Cassandra。 整合redisRedis是一个速度非常快的非关系型数据库（non-relational database），它可以存储键（key）与5种不同类型的值（value）之间的映射（mapping），可以将存储在内存的键值对数据持久化到硬盘。可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。 redis官网 redis中文社区 引入依赖Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redis，spring-boot-starter-data-redis依赖于spring-data-redis 和 lettuce 。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 参数配置在application.properties中加入Redis服务端的相关配置 ： 1234567891011121314151617#redis配置#Redis服务器地址spring.redis.host=127.0.0.1#Redis服务器连接端口spring.redis.port=6379#Redis数据库索引（默认为0）spring.redis.database=0 #连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=50#连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=3000ms#连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=20#连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=2#连接超时时间（毫秒）spring.redis.timeout=5000ms 其中 spring.redis.database 的配置通常使用0即可，Redis 在配置的时候可以设置数据库数量，默认为16，可以理解为数据库的 schema 测试访问通过编写测试用例，举例说明如何访问Redis。 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class FirstSampleApplicationTests &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Test public void test() throws Exception &#123; // 保存字符串 stringRedisTemplate.opsForValue().set("name", "chen"); Assert.assertEquals("chen", stringRedisTemplate.opsForValue().get("name")); &#125;&#125; 上面的案例通过自动配置的 StringRedisTemplate 对象进行 redis 的对写操作，从对象命名就可注意到支持的是string 类型，如果有用过 spring-data-redis 的开发者一定熟悉 RedisTemplate&lt;K,V&gt; 接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。 除了 String 类型，实战中经常会在 redis 中储存对象，我们就要在储存对象时对对象进行序列化。下面通过一个实例来完成对象的对写操作。 创建 User 实体 1234567@Datapublic class User implements Serializable &#123; private String userName; private Integer age;&#125; *配置针对对象的RedisTemplate实例 * 1234567891011121314151617181920212223242526272829@Configuration@EnableCachingpublic class RedisConfiguration extends CachingConfigurerSupport &#123; /** * 采用RedisCacheManager作为缓存管理器 * @param connectionFactory */ @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123; RedisCacheManager redisCacheManager = RedisCacheManager.create(connectionFactory); return redisCacheManager; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; //解决键、值序列化问题 StringRedisTemplate template = new StringRedisTemplate(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; *完成了配置工作后，编写测试用例实验效果 * 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class FirstSampleApplicationTests &#123; @Autowired RedisTemplate redisTemplate; @Test public void test() throws Exception &#123; //保存对象 User user = new User(); user.setUserName("chen"); user.setAge(22); redisTemplate.opsForValue().set(user.getUserName(), user); log.info("result:&#123;&#125;",redisTemplate.opsForValue().get("chen")); &#125;&#125; 这样我们就能对对象进行缓存了。但是在对 redis 更深入的了解中，一不小心就踩进坑里去了，下面对 redis 踩的坑做下记录。 踩坑记录踩坑1：cacheable注解引发的乱码问题1234567891011121314151617@RestController@RequestMapping("/chen/user")@Slf4jpublic class UserController &#123; @Autowired IUserService userService; @GetMapping("/hello") @Cacheable(value = "redis_key",key = "#name",unless = "#result == null") public User hello(@RequestParam("name")String name)&#123; User user = new User(); user.setName(name); user.setAge(22); user.setEmail("chen_ti@outlook.com"); return user; &#125;&#125; 在使用 SpringBoot1.x 的时候，通过简单的配置 RedisTemplete 就可以了，升级到 SpringBoot2.0，spring-boot-starter-data-redis 也跟着升起来了，@Cacheable 就出现了乱码的情况，可以通过将上面的配置文件 RedisConfiguration 做如下更改解决 ： 1234567891011121314151617181920212223242526272829303132333435363738@Configuration@EnableCachingpublic class RedisConfiguration extends CachingConfigurerSupport &#123; @Bean(name="redisTemplate") public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, String&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key序列化方式 template.setKeySerializer(redisSerializer); //value序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); // 配置序列化 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig(); RedisCacheConfiguration redisCacheConfiguration = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(redisCacheConfiguration) .build(); return cacheManager; &#125;&#125; 踩坑2：redis 获取缓存异常报错信息: 1java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.tuhu.twosample.chen.entity.User Redis获取缓存异常：java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX。 出现这种异常，我们需要自定义 ObjectMapper，设置一些参数，而不是直接使用 Jackson2JsonRedisSerializer 类中黙认的 ObjectMapper，看源代码可以知道，Jackson2JsonRedisSerializer 中的 ObjectMapper 是直接使用new ObjectMapper() 创建的，这样 ObjectMapper 会将 redis 中的字符串反序列化为 java.util.LinkedHashMap类型，导致后续 Spring 对其进行转换成报错。其实我们只要它返回 Object 类型就可以了。 使用以下方法，构建一个 Jackson2JsonRedisSerializer 对象，将其注入 RedisCacheManager 即可。 123456789101112131415161718/** * 通过自定义配置构建Redis的Json序列化器 * @return Jackson2JsonRedisSerializer对象 */ private Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer()&#123; Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.configure(MapperFeature.USE_ANNOTATIONS, false); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); // 此项必须配置，否则会报java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); return jackson2JsonRedisSerializer; &#125; 踩坑3：类转移路径异常打印: 1234519:32:47 INFO - Started Application in 10.932 seconds (JVM running for 12.296)19:32:50 INFO - get data from redis, key = 10d044f9-0e94-420b-9631-b83f5ca2ed3019:32:50 WARN - /market/renewal/homePage/indexorg.springframework.data.redis.serializer.SerializationException: Could not read JSON: Could not resolve type id 'com.pa.market.common.util.UserInfoExt' into a subtype of [simple type, class java.lang.Object]: no such class found at [Source: [B@641a684c; line: 1, column: 11]; nested exception is com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Could not resolve type id 'com.pa.market.common.util.UserInfoExt' into a subtype of [simple type, class java.lang.Object]: no such class found at [Source: [B@641a684c; line: 1, column: 11] *问题原因: * 项目中使用了拦截器，对每个 http 请求进行拦截。通过前端传递过来的 token，去 redis 缓存中获取用户信息UserInfoExt，用户信息是在用户登录的时候存入到 redis 缓存中的。根据获取到的用户信息来判断是否存是登录状态。 所以除白名单外的 url，其他请求都需要进行这个操作。通过日志打印，很明显出现在 UserInfoExt 对象存储到 redis 中序列化和反序列化的操作步骤。 解决办法: 12345678@Beanpublic RedisTemplate&lt;K, V&gt; redisTemplate() &#123; RedisTemplate&lt;K, V&gt; redisTemplate = new RedisTemplate&lt;K, V&gt;(); redisTemplate.setConnectionFactory(jedisConnectionFactory()); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); return redisTemplate; &#125; 查看 redis 的 Bean 定义发现，对 key 的序列化使用的是 StringRedisSerializer 系列化，value 值的序列化是GenericJackson2JsonRedisSerializer 的序列化方法。 其中 GenericJackson2JsonRedisSerializer 序列化方法会在 redis 中记录类的 @class 信息，如下所示： 12345&#123; "@class": "com.pa.market.common.util.UserInfoExt", "url": "www.baidu.com", "name": "baidu"&#125; “@class”: “com.pa.market.common.util.UserInfoExt”，每个对象都会有这个 id 存在（可以通过源码看出为嘛有这个 @class），如果用户一直处在登录状态，是以 com.pa.market.common.util.UserInfoExt 这个路径进行的序列化操作。但是移动了 UserInfoExt 的类路径后，包全名变了。所以会抛出 no such class found 的异常。这样在判断用户是否存在的地方就抛出了异常，故而所有的请求都失败了，已经登录的用户没法进行任何操作。 ok 把踩的坑都记录下来，终于呼出了最后一口气，以后遇到这种坑都能从容的避开了，但是 redis 中的坑还有很多，可能以后还是会轻轻松松的跳进去。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 中的 Optional 类的基本使用]]></title>
    <url>%2F2018%2F10%2F10%2FJava8%20%E4%B8%AD%E7%9A%84%20Optional%20%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java8 引入了一个十分有趣的 Optional 类它主要是为了解决臭名昭著的空指针异常（NullPointerException）。当我们对对象的属性进行检查，判断它的值是否为期望的格式，最终却发现我们查看的并不是一个对象，而是一个空指针，它会立即抛出一个让人厌烦的 NullPointerException 异常。 抛砖我们来看一个简单的实例： 1String address = world.getCountry.getCity.getName; 在得到地址之前，需要对各个类进行检查防止出现空指针异常： 12345678910111213public String getAddress(World world)&#123; if (world != null)&#123; Country country = world.getCountry(); if (country!=null)&#123; City city = country.getCity(); if (city != null)&#123; return city.getName(); &#125; &#125; &#125; return "unknown"; &#125; 可以看到上面的检查有多么繁杂，代码中充斥着空检查，可读性糟糕透顶。 Optional 类入门变量存在时， Optional 类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空” 的 Optional 对象，由方法 Optional.empty() 返回。 那你可能就会疑惑，null 和 Optional.empty() 的区别在哪呢？从语义上，你可以把它们当作一回事儿，但是实际中它们之间的差别非常 大 ： 如果你尝试解引用一个 null ， 一定会触发NullPointerException ， 不过使用 Optional.empty() 就完全没事儿，它是 Optional 类的一个有效对象，多种场景都能调用，非常有用。 应用 Optional 的几种模式创建 Optional 对象实例可以创建一个空的 Optional 对象实例 12345@Test(expected = NoSuchElementException.class) public void createOptionalObject()&#123; Optional&lt;String&gt; country = Optional.empty(); country.get(); &#125; 毫无疑问，当我们调用 get() 方法会报 NoSuchElementException 异常 还可以使用 of() 和 ofNullable() 方法创建包含值的 Optioanal 实例，区别在于如果将 null 当作参数传进去 of() 会报空指针异常，所以对象可能存在或者不存在，应该使用 ofNullable() 12345678@Test public void createOptionalObject()&#123; Optional&lt;String&gt; country = Optional.of("中国"); Optional&lt;String&gt; city = Optional.ofNullable("上海"); Optional&lt;String&gt; world = Optional.ofNullable(null); //下面会报空指针异常 Optional&lt;String&gt; province = Optional.of(null); &#125; 如何获取Optional变量中的值 ？Optional 提供了一个 get() 方法。不过 get方法在遭遇到空的Optional对象时也会抛出异常，所以不按照约定的方式使用它，又会让我们再度陷入由null引起的代码维护的梦魇。 访问 Optional 对象的值从 Optional 实例中取回实际值对象的方法之一是使用 get() 方法： 1234567@Test public void getOptionalObject()&#123; String country = "China" Optional&lt;String&gt; countryName = Optional.ofNullable(country); Assert.assertEquals("China",countryName.get()); &#125; 当然这个方法会在值为null时抛出异常，要避免异常，首先要进行检查 12345678@Test public void getOptionalObject()&#123; City city = new City("ShangHai"); Optional&lt;City&gt; sample = Optional.ofNullable(city); Assert.assertTrue(sample.isPresent()); Assert.assertEquals(city.getName(),sample.get().getName()); &#125; 检查是否有值还有另外一个方法 ifPresent()，该方法除了检查还会传入一个 Consumer(消费者) 参数，如果对象不是空的，就会执行传入的 Lambda 表达式 123456@Test public void getOptionalObject()&#123; City city = new City("ShangHai"); Optional&lt;City&gt; sample = Optional.ofNullable(city); sample.ifPresent(c -&gt; Assert.assertEquals(city.getName(),sample.get().getName())); &#125; 如果对象不为空则为执行断言 返回默认值Optional 提供了 API 用以返回对象值，或者在对象为空的时候返回默认值 1234567@Test public void getOptionalObject()&#123; City city = null; City city1 = new City("ShangHai"); City sample = Optional.ofNullable(city).orElse(city1); Assert.assertEquals(city1.getName(),sample.getName()); &#125; 第二个同类型的 API 是 orElseGet() —— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的 Supplier(供应者) 函数式接口，并将返回其执行结果： 1City sample = Optional.ofNullable(city).orElseGet(() -&gt; city1); 返回异常Optional 还定义了 orElseThrow() API 它会在对象为空时抛出异常 12345@Test(expected = IllegalArgumentException.class) public void throwOptionalException()&#123; City city = null; City sample = Optional.ofNullable(city).orElseThrow(() -&gt; new IllegalArgumentException()); &#125; city 为空所以会抛出 IllegalArgumentException 这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 NullPointerException。 使用 Optional 的实战实例使用map从 Optional 对象中提取和转换值从对象中提取信息是一种比较常见的模式，为了支持这种模式，Optional提供了一个map方法。它的工作方式如下: 123456@Test public void getCityName()&#123; City city = new City(&quot;ShangHai&quot;); Optional&lt;City&gt; sample = Optional.ofNullable(city); Optional&lt;String&gt; name = sample.map(City::getName); &#125; map 对值应用(调用)作为参数的函数，然后将返回的值包装在 Optional 中，这就使对返回值进行链试调用的操作成为可能，那是不是就可以对之前的代码进行重构呢？ 12345678910public Optional&lt;String&gt; getCityName(World world)&#123; Optional&lt;World&gt; real = Optional.ofNullable(world); Optional&lt;String&gt; name = real.map(World::getCountry) .map(Country::getCity) .map(City::getName); return name; &#125; 但是这段代码无法通过编译，real.map(World::getCountry) 返回的是 Optional&lt;Country&gt; 的实例这个没有问题，但是后面继续调用map产生的就是 Optional&lt;Optional&lt;Country&gt;&gt;类型的对象。说明你遭遇了嵌套式的 Optional 机构。 两层Optional对象结构 使用 flatMap 链接 Optional 对象所以，我们该如何解决这个问题呢？让我们再回顾一下你刚刚在流上使用过的模式： flatMap 方法。使用流时， flatMap 方法接受一个函数作为参数，这个函数的返回值是另一个流。 这个方法会应用到流中的每一个元素，最终形成一个新的流的流。但是 flagMap 会用流的内容替 换每个新生成的流。换句话说，由方法生成的各个流会被合并或者扁平化为一个单一的流。这里 你希望的结果其实也是类似的，但是你想要的是将两层的 optional 合并为一个。 12345678910public Optional&lt;String&gt; getCityName(World world)&#123; Optional&lt;World&gt; real = Optional.ofNullable(world); Optional&lt;String&gt; name = real.flagMap(World::getCountry) .flagMap(Country::getCity) .map(City::getName); return name; &#125; 使用 filter 剔除特定的值你经常需要调用某个对象的方法，那么你首先要检查对象是否为NULL 12345678public void filterCity(City city)&#123; Optional&lt;City&gt; real = Optional.ofNullable(city); real.filter(c -&gt; c!=null &amp;&amp; "ShangHai" .equals(c.getName())) .ifPresent(x -&gt; System.out.println("ok"));&#125; 小结 null 引用在历史上被引入到程序设计语言中，目的是为了表示变量值的缺失。 Java 8中引入了一个新的类 java.util.Optional，对存在或缺失的变量值进行 建模。 你可以使用静态工厂方法 Optional.empty、 Optional.of 以及 Optional.ofNullable 创建 Optional 对象。 Optional类支持多种方法，比如 map、 flatMap、 filter，它们在概念上与 Stream 类中对应的方法十分相似。 使用 Optional 会迫使你更积极地解引用 Optional 对象，以应对变量值缺失的问题，最终，你能更有效地防止代码中出现不期而至的空指针异常。 使用 Optional 能帮助你设计更好的 API，用户只需要阅读方法签名，就能了解该方法是否接受一个 Optional类型的值。 ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 优雅解决 ajax 跨域请求]]></title>
    <url>%2F2018%2F08%2F10%2FSpringBoot%20%E4%BC%98%E9%9B%85%E8%A7%A3%E5%86%B3%20ajax%20%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[今天打开页面报错，地址是有效的，但浏览器会报 “No ‘Access-Control-Allow-Origin’ header is present on the requested resource “ 错误页面如下： 这是由于 ajax 跨域请求造成的 什么是跨域由于浏览器同源策略（同源策略，它是由 Netscape 提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指域名、协议、端口相同），凡是发送请求 url 的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。 How does it works ?CORS请求（包括预选的带有选项方法）被自动注册到各种 HandlerMapping 。他们处理 CROS 准备请求并拦截 CORS 简单和实际请求，这得益于 CorsProcessor 实现（默认情况下默认DefaultCorsProcessor 处理器），以便添加相关的CORS响应头（如 Access-Control-Allow-Origin ）。 CorsConfiguration 允许您指定CORS请求应该如何处理：允许 origins, headers, methods 等。 a、AbstractHandlerMapping#setCorsConfiguration() 允许指定一个映射，其中有几个CorsConfiguration 映射在路径模式上，比如/api/**。 b、子类可以通过重写AbstractHandlerMapping类的getCorsConfiguration(Object, HttpServletRequest)方法来提供自己的CorsConfiguration。 c、处理程序可以实现 CorsConfigurationSource 接口（如ResourceHttpRequestHandler），以便为每个请求提供一个CorsConfiguration。 如何解决普通跨域请求解决方案1. 请求接口添加注解 @CrossOrigin(origins = &quot;*&quot;, maxAge = 3600) 说明：origins = &quot;*&quot; origins 值为当前请求该接口的域 2. 通用配置 123456789101112131415161718192021222324/** * 跨域请求配置 * @author chendesheng * @create 2019/9/16 19:07 */@Configurationpublic class CorsConfig &#123; @Bean public CorsFilter corsFilter()&#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**",buildconfig()); return new CorsFilter(source); &#125; private CorsConfiguration buildconfig()&#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); corsConfiguration.addAllowedHeader("*"); corsConfiguration.addAllowedMethod("*"); return corsConfiguration; &#125;&#125; ajax自定义headers的跨域请求1234567891011121314$.ajax(&#123; type:"GET", url:"http://localhost:8766/main/currency/sginInState", dataType:"JSON", data:&#123; uid:userId &#125;, beforeSend: function (XMLHttpRequest) &#123; XMLHttpRequest.setRequestHeader("Authorization", access_token); &#125;, success:function(res)&#123; console.log(res.code) &#125; &#125;) 此处请求报错：OPTIONS http://localhost:8766/main/currency/sginInState 500 普通跨域的解决方案已经无法解决这种问题，为什么会出现OPTIONS请求呢？ 原因： 浏览器会在发送真正请求之前，先发送一个方法为OPTIONS的预检请求 Preflighted requests 这个请求是用来验证本次请求是否安全的，但是并不是所有请求都会发送，需要符合以下条件： 请求方法不是GET/HEAD/POST POST 请求的 Content-Type 并非 application/x-www-form-urlencoded, multipart/form-data 或text/plain 请求设置了自定义的header字段 对于管理端的接口，我有对接口进行权限校验，每次请求需要在header中携带自定义的字段（token），所以浏览器会多发送一个 OPTIONS 请求去验证此次请求的安全性。 为何 OPTIONS 请求是500呢？ OPTIONS请求只会携带自定义的字段，并不会将相应的值带入进去，而后台校验 token 字段时 token 为 NULL，所以验证不通过，抛出了一个异常。 如何解决这个异常？ 1. spring boot项目application.yml中添加 123spring:mvc:dispatch-options-request: true 2. 添加过滤器配置 第一步：手写 RequestFilter 请求过滤器配置类此类需要实现 HandlerInterceptor 类，HandlerInterceptor 类是 org.springframework.web.servlet.HandlerInterceptor 下的。 具体代码如下： 12345678910111213141516@Componentpublic class RequestFilter implements HandlerInterceptor &#123; public boolean preHandler(HttpServletRequest request,HttpServletResponse response,Object handler)&#123; response.setHeader("Access-Control-Allow-Origin", "*"); response.setHeader("Access-Control-Allow-Credentials", "true"); response.setHeader("Access-Control-Allow-Methods", "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS"); response.setHeader("Access-Control-Max-Age", "86400"); response.setHeader("Access-Control-Allow-Headers", "Authorization"); // 如果是OPTIONS请求则结束 if (HttpMethod.OPTIONS.toString().equals(request.getMethod())) &#123; response.setStatus(HttpStatus.NO_CONTENT.value()); return false; &#125; return true; &#125;&#125; 第二步：手写 MyWebConfiguration 此类需要继承 WebMvcConfigurationSupport 。 具体代码实现： 12345678910@Componentpublic class MyWebConfiguration extends WebMvcConfigurationSupport&#123; @Resource private RequestFilter requestFilter; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 跨域拦截器 registry.addInterceptor(requestFilter).addPathPatterns("/**"); &#125;&#125; 这样就优雅的解决了 ajax 跨域请求的问题。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 中使用 RabbitMQ]]></title>
    <url>%2F2018%2F07%2F20%2FSpringBoot%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20RabbitMQ%2F</url>
    <content type="text"><![CDATA[今日内容是消息队列。大佬讲了三个消息队列分别是 Pegion、Kafka 和 RabbitMQ。其中 Pegion 是公司自己研发的组件。今天主要在 SpringBoot 中集成 RabbitMQ , 将消息储存在消息队列中并消费的过程。 Message Broker 与 AMQP 简介Message Broker 是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景： 消息路由到一个或多个目的地 消息转化为其他的表现方式 执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户 调用Web服务来检索数据 响应事件或错误 使用发布-订阅模式来提供内容或基于主题的消息路由 AMQP 是 Advanced Message Queuing Protocol 的简称，它是一个面向消息中间件的开放式标准应用层协议。AMQP 定义了这些特性： 消息方向 消息队列 消息路由（包括：点到点和发布-订阅模式） 可靠性 安全性 RabbitMQ本文要介绍的 RabbitMQ 就是以 AMQP 协议实现的一种中间件产品，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。 SpringBoot整合下面，我们通过在 SpringBoot 应用中整合 RabbitMQ，并实现一个简单的发送、接收消息的例子来对 RabbitMQ 有一个直观的感受和理解。 在 SpringBoot 中整合 RabbitMQ 是一件非常容易的事，因为之前我们已经介绍过 Starter POMs，其中的 AMQP 模块就可以很好的支持 RabbitMQ，下面我们就来详细说说整合过程： 新建一个 SpringBoot 工程，命名为：“rabbitmq-hello”。 在pom.xml中引入如下依赖内容，其中spring-boot-starter-amqp用于支持 RabbitMQ。 1234567891011121314151617&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.properties中配置关于RabbitMQ的连接和用户信息，用户可以回到上面的安装内容，在管理页面中创建用户。 123456spring.application.name=rabbitmq-hellospring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=springspring.rabbitmq.password=123456 创建消息生产者Sender。通过注入AmqpTemplate接口的实例来实现消息的发送，AmqpTemplate接口定义了一套针对AMQP协议的基础操作。在 SpringBoot 中会根据配置来注入其具体实现。在该生产者，我们会产生一个字符串，并发送到名为hello的队列中。 12345678910111213@Componentpublic class Sender &#123; @Autowired private AmqpTemplate rabbitTemplate; public void send() &#123; String context = "hello " + new Date(); System.out.println("Sender : " + context); this.rabbitTemplate.convertAndSend("hello", context); &#125;&#125; 创建消息消费者Receiver。通过@RabbitListener注解定义该类对hello队列的监听，并用@RabbitHandler注解来指定对消息的处理方法。所以，该消费者实现了对hello队列的消费，消费操作为输出消息的字符串内容。 12345678910@Component@RabbitListener(queues = "hello")public class Receiver &#123; @RabbitHandler public void process(String hello) &#123; System.out.println("Receiver : " + hello); &#125;&#125; 创建RabbitMQ的配置类RabbitConfig，用来配置队列、交换器、路由等高级信息。这里我们以入门为主，先以最小化的配置来定义，以完成一个基本的生产和消费过程。 123456789@Configurationpublic class RabbitConfig &#123; @Bean public Queue helloQueue() &#123; return new Queue("hello"); &#125;&#125; 创建应用主类： 12345678@SpringBootApplicationpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 创建单元测试类，用来调用消息生产： 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = HelloApplication.class)public class HelloApplicationTests &#123; @Autowired private Sender sender; @Test public void hello() throws Exception &#123; sender.send(); &#125;&#125; 完成程序编写之后，下面开始尝试运行。首先确保 RabbitMQ Server 已经开始，然后进行下面的操作： 启动应用主类，从控制台中，我们看到如下内容，程序创建了一个访问127.0.0.1:5672中springcloud的连接。 1o.s.a.r.c.CachingConnectionFactory : Created new connection: SimpleConnection@29836d32 [delegate=amqp://springcloud@127.0.0.1:5672/] 同时，我们通过 RabbitMQ 的控制面板，可以看到 Connection 和 Channels 中包含当前连接的条目。 运行单元测试类，我们可以看到控制台中输出下面的内容，消息被发送到了 RabbitMQ Server 的hello队列中。 1Sender : hello Sun Sep 25 11:06:11 CST 2016 切换到应用主类的控制台，我们可以看到类似如下输出，消费者对hello队列的监听程序执行了，并输出了接受到的消息信息。 1Receiver : hello Sun Sep 25 11:06:11 CST 2016 大功告成！]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请给百度网盘加速100倍]]></title>
    <url>%2F2018%2F07%2F12%2F%E8%AF%B7%E7%BB%99%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8A%A0%E9%80%9F100%E5%80%8D%2F</url>
    <content type="text"><![CDATA[相信小伙伴平时的文件、资源都会保存在百度网盘上，但是有些资源比如视频是不能在线观看的，所以只能下载下来，但是除非我们是百度尊贵的 vip ，否则一定会为百度网盘的龟速下载抓狂，所以这里就要给百度网盘加速100倍，享受飞一般的感觉。 废话不多说先上图看效果，可以看到下载速度接近 3MB 每秒，这个速度依赖现有网络。 工具：proxyee-down 工具地址：https://github.com/proxyee-down-org/proxyee-down 考虑到这个步骤有一些坑，尤其是没有技术背景的看文档可能还是有点困难，我这里把我的步骤讲一下，希望能够尽可能帮助到大家少走弯路。 下载工具地址：https://imhx-my.sharepoint.com/personal/pd_imhx_onmicrosoft_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fpd_imhx_onmicrosoft_com%2FDocuments%2Fproxyee-down 里面有对应的版本，根据不同的操作系统下载就行。 比如我电脑版本是 windows 64 下载的是 Proxyee Down.3.4.windows.x64.7z 操作解压并运行 安装插件打开软件后，来到扩展管理这栏，里面有三个扩展： 百度云下载 全网嗅探 B站视频下载 下载百度云下载扩展并且打开开关 使用打开百度云网盘网页，点击直链下载。就会切换到 proxyee-down 进行下载啦~ 百度云100倍下载之旅现在开始啦，嘎嘎嘎嘎 ~]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
