<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis参数格式化异常]]></title>
    <url>%2F2019%2F09%2F11%2Fmybatis%E5%8F%82%E6%95%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[昨天运行程序，程序报了mybatis参数格式化异常:NumberFormatException: For input string:”xx”，错误日志如下： 错误日记12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879[16/08/16 02:15:40:040 CST] http-nio-8080-exec-4 ERROR filter.ExceptionFilter: [DUBBO] Got unchecked and undeclared exception which called by 127.0.0.1. service: cn.test.web.service.ShareService, method: getShareChannelStInfoList, exception: org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.NumberFormatException: For input string: "2016-08-11"### Cause: java.lang.NumberFormatException: For input string: "2016-08-11", dubbo version: 2.8.4, current host: 127.0.0.1org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: java.lang.NumberFormatException: For input string: "2016-08-11"### Cause: java.lang.NumberFormatException: For input string: "2016-08-11" at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:76) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:399) at com.sun.proxy.$Proxy32.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:205) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:122) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:64) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:53) at com.sun.proxy.$Proxy57.getShareChannelStInfo(Unknown Source) at cn.test.web.repository.ShareStInfoRepo.getShareChannelList(ShareStInfoRepo.java:37) at cn.test.web.impl.ShareServiceImpl.getShareChannelStInfoList(ShareServiceImpl.java:72) at com.alibaba.dubbo.common.bytecode.Wrapper19.invokeMethod(Wrapper19.java) at com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory$1.doInvoke(JavassistProxyFactory.java:46) at com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker.invoke(AbstractProxyInvoker.java:72) at com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:53) at com.alibaba.dubbo.rpc.filter.ExceptionFilter.invoke(ExceptionFilter.java:64) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.TimeoutFilter.invoke(TimeoutFilter.java:42) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter.invoke(TraceFilter.java:78) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.ContextFilter.invoke(ContextFilter.java:70) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.GenericFilter.invoke(GenericFilter.java:132) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.ClassLoaderFilter.invoke(ClassLoaderFilter.java:38) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.filter.EchoFilter.invoke(EchoFilter.java:38) at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91) at com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:52) at com.alibaba.dubbo.common.bytecode.proxy9.getShareChannelStInfoList(proxy9.java) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:137) at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:288) at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:242) at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:229) at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:356) at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:179) at org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:220) at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:56) at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:51) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer$RestHandler.handle(DubboHttpServer.java:86) at com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet.service(DispatcherServlet.java:64) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:616) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:528) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1099) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1520) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1476) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 错误代码这段代码，就是mybatis的动态查询，就是组装sql语句。但是，这里必须注意一个问题，那就是departmentName 和 ordertime,这两个变量是EarlyOrder中的私有变量，是String类型的。 错误的引起，是 departmentName != 0 引起的，原因给的是字符串，却拿一个数字比较，mybatis会做一些转化，结果在数字格式化时发生异常。 1234567891011121314&lt;select id="selectEarlyOrder" resultType="com.example.demo.model.EarlyOrder"&gt; select username,ordertime,overworktime,status,departmentname from tabordermeal &lt;where&gt; 1=1 &lt;if test="departmentName != 0 and departmentName != '' and departmentName !=null and departmentName != 'null'"&gt; and departmentName = #&#123;departmentName&#125; &lt;/if&gt; &lt;if test="ordertime != '' and ordertime !=null and ordertime != 'null'"&gt; and ordertime LIKE '$&#123;ordertime&#125;%' &lt;/if&gt; &lt;/where&gt; limit #&#123;pageindex&#125;,#&#123;pagesize&#125; &lt;/select&gt; 解决错误加单引号是无法解决的，比如：departmentName != &#39;0&#39;，此时，mybatis认为拿一个字符串(String)和一个字符(char)比较，也会报错。 因此，有几种方法可以解决此问题： 转成字符串：&#39;0&#39;.toString()1234567891011121314&lt;select id="selectEarlyOrder" resultType="com.example.demo.model.EarlyOrder"&gt; select username,ordertime,overworktime,status,departmentname from tabordermeal &lt;where&gt; 1=1 &lt;if test="departmentName != '0'.toString() and departmentName != '' and departmentName !=null and departmentName != 'null'"&gt; and departmentName = #&#123;departmentName&#125; &lt;/if&gt; &lt;if test="ordertime != '' and ordertime !=null and ordertime != 'null'"&gt; and ordertime LIKE '$&#123;ordertime&#125;%' &lt;/if&gt; &lt;/where&gt; limit #&#123;pageindex&#125;,#&#123;pagesize&#125; &lt;/select&gt; 加转义实体字符串引号&amp;quot;1&lt;if test=\"departmentName != null and departmentName != "0"\"&gt; 外部单双引号交换：1&lt;if test='startd != null and startd != \"0\"'&gt; 注意：在xml配置中，使用第三种方式，不需要添加反斜杠(“\“),&lt;if test=&#39;startd != null and startd != &quot;0&quot;&#39;&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2019%2F09%2F11%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等；]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java8 中的 Optional 类的基本使用]]></title>
    <url>%2F2018%2F10%2F10%2FJava8%20%E4%B8%AD%E7%9A%84%20Optional%20%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java8 引入了一个十分有趣的 Optional 类它主要是为了解决臭名昭著的空指针异常（NullPointerException）。当我们对对象的属性进行检查，判断它的值是否为期望的格式，最终却发现我们查看的并不是一个对象，而是一个空指针，它会立即抛出一个让人厌烦的 NullPointerException 异常。 我们来看一个简单的实例： 1String address = world.getCountry.getCity.getName; 在得到地址之前，需要对各个类进行检查防止出现空指针异常： 12345678910111213public String getAddress(World world)&#123; if (world != null)&#123; Country country = world.getCountry(); if (country!=null)&#123; City city = country.getCity(); if (city != null)&#123; return city.getName(); &#125; &#125; &#125; return "unknown"; &#125; 可以看到上面的检查有多么繁杂，代码中充斥着空检查，可读性糟糕透顶。 Optional 类入门变量存在时， Optional 类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空” 的 Optional 对象，由方法 Optional.empty() 返回。 那你可能就会疑惑，null 和 Optional.empty() 的区别在哪呢？从语义上，你可以把它们当作一回事儿，但是实际中它们之间的差别非常 大 ： 如果你尝试解引用一个 null ， 一定会触发NullPointerException ， 不过使用 Optional.empty() 就完全没事儿，它是 Optional 类的一个有效对象，多种场景都能调用，非常有用。 应用 Optional 的几种模式创建 Optional 对象实例可以创建一个空的 Optional 对象实例 12345@Test(expected = NoSuchElementException.class) public void createOptionalObject()&#123; Optional&lt;String&gt; country = Optional.empty(); country.get(); &#125; 毫无疑问，当我们调用 get() 方法会报 NoSuchElementException 异常 还可以使用 of() 和 ofNullable() 方法创建包含值的 Optioanal 实例，区别在于如果将 null 当作参数传进去 of() 会报空指针异常，所以对象可能存在或者不存在，应该使用 ofNullable() 12345678@Test public void createOptionalObject()&#123; Optional&lt;String&gt; country = Optional.of("中国"); Optional&lt;String&gt; city = Optional.ofNullable("上海"); Optional&lt;String&gt; world = Optional.ofNullable(null); //下面会报空指针异常 Optional&lt;String&gt; province = Optional.of(null); &#125; 如何获取Optional变量中的值 ？Optional 提供了一个 get() 方法。不过 get方法在遭遇到空的Optional对象时也会抛出异常，所以不按照约定的方式使用它，又会让我们再度陷入由null引起的代码维护的梦魇。 访问 Optional 对象的值从 Optional 实例中取回实际值对象的方法之一是使用 get() 方法： 1234567@Test public void getOptionalObject()&#123; String country = "China" Optional&lt;String&gt; countryName = Optional.ofNullable(country); Assert.assertEquals("China",countryName.get()); &#125; 当然这个方法会在值为null时抛出异常，要避免异常，首先要进行检查 12345678@Test public void getOptionalObject()&#123; City city = new City("ShangHai"); Optional&lt;City&gt; sample = Optional.ofNullable(city); Assert.assertTrue(sample.isPresent()); Assert.assertEquals(city.getName(),sample.get().getName()); &#125; 检查是否有值还有另外一个方法 ifPresent()，该方法除了检查还会传入一个 Consumer(消费者) 参数，如果对象不是空的，就会执行传入的 Lambda 表达式 123456@Test public void getOptionalObject()&#123; City city = new City("ShangHai"); Optional&lt;City&gt; sample = Optional.ofNullable(city); sample.ifPresent(c -&gt; Assert.assertEquals(city.getName(),sample.get().getName())); &#125; 如果对象不为空则为执行断言 返回默认值Optional 提供了 API 用以返回对象值，或者在对象为空的时候返回默认值 1234567@Test public void getOptionalObject()&#123; City city = null; City city1 = new City("ShangHai"); City sample = Optional.ofNullable(city).orElse(city1); Assert.assertEquals(city1.getName(),sample.getName()); &#125; 第二个同类型的 API 是 orElseGet() —— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的 Supplier(供应者) 函数式接口，并将返回其执行结果： 1City sample = Optional.ofNullable(city).orElseGet(() -&gt; city1); 返回异常Optional 还定义了 orElseThrow() API 它会在对象为空时抛出异常 12345@Test(expected = IllegalArgumentException.class) public void throwOptionalException()&#123; City city = null; City sample = Optional.ofNullable(city).orElseThrow(() -&gt; new IllegalArgumentException()); &#125; city 为空所以会抛出 IllegalArgumentException 这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 NullPointerException。 使用 Optional 的实战实例使用map从 Optional 对象中提取和转换值从对象中提取信息是一种比较常见的模式，为了支持这种模式，Optional提供了一个map方法。它的工作方式如下: 123456@Test public void getCityName()&#123; City city = new City(&quot;ShangHai&quot;); Optional&lt;City&gt; sample = Optional.ofNullable(city); Optional&lt;String&gt; name = sample.map(City::getName); &#125; map 对值应用(调用)作为参数的函数，然后将返回的值包装在 Optional 中，这就使对返回值进行链试调用的操作成为可能，那是不是就可以对之前的代码进行重构呢？ 12345678910public Optional&lt;String&gt; getCityName(World world)&#123; Optional&lt;World&gt; real = Optional.ofNullable(world); Optional&lt;String&gt; name = real.map(World::getCountry) .map(Country::getCity) .map(City::getName); return name; &#125; 但是这段代码无法通过编译，real.map(World::getCountry) 返回的是 Optional&lt;Country&gt; 的实例这个没有问题，但是后面继续调用map产生的就是 ``Optional&lt;Optional&gt;`类型的对象。说明你遭遇了嵌套式的 Optional 机构。 两层Optional对象结构 使用 flatMap 链接 Optional 对象所以，我们该如何解决这个问题呢？让我们再回顾一下你刚刚在流上使用过的模式： flatMap 方法。使用流时， flatMap 方法接受一个函数作为参数，这个函数的返回值是另一个流。 这个方法会应用到流中的每一个元素，最终形成一个新的流的流。但是 flagMap 会用流的内容替 换每个新生成的流。换句话说，由方法生成的各个流会被合并或者扁平化为一个单一的流。这里 你希望的结果其实也是类似的，但是你想要的是将两层的 optional 合并为一个。 12345678910public Optional&lt;String&gt; getCityName(World world)&#123; Optional&lt;World&gt; real = Optional.ofNullable(world); Optional&lt;String&gt; name = real.flagMap(World::getCountry) .flagMap(Country::getCity) .map(City::getName); return name; &#125; 使用 filter 剔除特定的值你经常需要调用某个对象的方法，那么你首先要检查对象是否为NULL 12345678public void filterCity(City city)&#123; Optional&lt;City&gt; real = Optional.ofNullable(city); real.filter(c -&gt; c!=null &amp;&amp; "ShangHai" .equals(c.getName())) .ifPresent(x -&gt; System.out.println("ok"));&#125; 小结 null 引用在历史上被引入到程序设计语言中，目的是为了表示变量值的缺失。 Java 8中引入了一个新的类 java.util.Optional，对存在或缺失的变量值进行 建模。 你可以使用静态工厂方法 Optional.empty、 Optional.of 以及 Optional.ofNullable 创建 Optional 对象。 Optional类支持多种方法，比如 map、 flatMap、 filter，它们在概念上与 Stream 类 中对应的方法十分相似。 使用 Optional 会迫使你更积极地解引用 Optional 对象，以应对变量值缺失的问题，最 终，你能更有效地防止代码中出现不期而至的空指针异常。 使用 Optional 能帮助你设计更好的 API，用户只需要阅读方法签名，就能了解该方法是 否接受一个 Optional类型的值。 ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 中使用 RabbitMQ]]></title>
    <url>%2F2018%2F07%2F20%2FSpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8RabbitMQ%2F</url>
    <content type="text"><![CDATA[今日内容是消息队列。大佬讲了三个消息队列分别是 Pegion、Kafka 和 RabbitMQ。其中 Pegion 是公司自己研发的组件。今天主要在 SpringBoot 中集成 RabbitMQ , 将消息储存在消息队列中并消费的过程。 Message Broker 与 AMQP 简介Message Broker 是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景： 消息路由到一个或多个目的地 消息转化为其他的表现方式 执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户 调用Web服务来检索数据 响应事件或错误 使用发布-订阅模式来提供内容或基于主题的消息路由 AMQP 是 Advanced Message Queuing Protocol 的简称，它是一个面向消息中间件的开放式标准应用层协议。AMQP 定义了这些特性： 消息方向 消息队列 消息路由（包括：点到点和发布-订阅模式） 可靠性 安全性 RabbitMQ本文要介绍的 RabbitMQ 就是以 AMQP 协议实现的一种中间件产品，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。 SpringBoot整合下面，我们通过在 SpringBoot 应用中整合 RabbitMQ，并实现一个简单的发送、接收消息的例子来对 RabbitMQ 有一个直观的感受和理解。 在 SpringBoot 中整合 RabbitMQ 是一件非常容易的事，因为之前我们已经介绍过 Starter POMs，其中的 AMQP 模块就可以很好的支持 RabbitMQ，下面我们就来详细说说整合过程： 新建一个 SpringBoot 工程，命名为：“rabbitmq-hello”。 在pom.xml中引入如下依赖内容，其中spring-boot-starter-amqp用于支持 RabbitMQ。 1234567891011121314151617&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.properties中配置关于RabbitMQ的连接和用户信息，用户可以回到上面的安装内容，在管理页面中创建用户。 123456spring.application.name=rabbitmq-hellospring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=springspring.rabbitmq.password=123456 创建消息生产者Sender。通过注入AmqpTemplate接口的实例来实现消息的发送，AmqpTemplate接口定义了一套针对AMQP协议的基础操作。在 SpringBoot 中会根据配置来注入其具体实现。在该生产者，我们会产生一个字符串，并发送到名为hello的队列中。 12345678910111213@Componentpublic class Sender &#123; @Autowired private AmqpTemplate rabbitTemplate; public void send() &#123; String context = "hello " + new Date(); System.out.println("Sender : " + context); this.rabbitTemplate.convertAndSend("hello", context); &#125;&#125; 创建消息消费者Receiver。通过@RabbitListener注解定义该类对hello队列的监听，并用@RabbitHandler注解来指定对消息的处理方法。所以，该消费者实现了对hello队列的消费，消费操作为输出消息的字符串内容。 12345678910@Component@RabbitListener(queues = "hello")public class Receiver &#123; @RabbitHandler public void process(String hello) &#123; System.out.println("Receiver : " + hello); &#125;&#125; 创建RabbitMQ的配置类RabbitConfig，用来配置队列、交换器、路由等高级信息。这里我们以入门为主，先以最小化的配置来定义，以完成一个基本的生产和消费过程。 123456789@Configurationpublic class RabbitConfig &#123; @Bean public Queue helloQueue() &#123; return new Queue("hello"); &#125;&#125; 创建应用主类： 12345678@SpringBootApplicationpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 创建单元测试类，用来调用消息生产： 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = HelloApplication.class)public class HelloApplicationTests &#123; @Autowired private Sender sender; @Test public void hello() throws Exception &#123; sender.send(); &#125;&#125; 完成程序编写之后，下面开始尝试运行。首先确保 RabbitMQ Server 已经开始，然后进行下面的操作： 启动应用主类，从控制台中，我们看到如下内容，程序创建了一个访问127.0.0.1:5672中springcloud的连接。 1o.s.a.r.c.CachingConnectionFactory : Created new connection: SimpleConnection@29836d32 [delegate=amqp://springcloud@127.0.0.1:5672/] 同时，我们通过 RabbitMQ 的控制面板，可以看到 Connection 和 Channels 中包含当前连接的条目。 运行单元测试类，我们可以看到控制台中输出下面的内容，消息被发送到了 RabbitMQ Server 的hello队列中。 1Sender : hello Sun Sep 25 11:06:11 CST 2016 切换到应用主类的控制台，我们可以看到类似如下输出，消费者对hello队列的监听程序执行了，并输出了接受到的消息信息。 1Receiver : hello Sun Sep 25 11:06:11 CST 2016 大功告成！]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
</search>
